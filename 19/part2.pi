import sat.
import util.

main =>
  Lines = read_file_lines(),
  Blueprints = take(map(parse_line, Lines), 3),

  Res = 1,
  println(Blueprints),
  foreach(I in 1..length(Blueprints))
    Blueprint = Blueprints[I],
    println(Blueprint),
    Geodes = calc(Blueprint),
    println(Geodes),
    Res := Res * Geodes
  end,
  println(res=Res).

calc(Blueprint) = R =>
  N = 33,
  Actions = new_array(N),
  Actions :: 0..4,
  Actions[1] #= 0,  % fake action for time 1: a dummy timestep so we can more easily derive values for the next step
  Ore = new_array(N),
  Ore :: 0..255,
  Ore[1] #= 0,
  Clay = new_array(N),
  Clay :: 0..255,
  Clay[1] #= 0,
  Obsidian = new_array(N),
  Obsidian :: 0..255,
  Obsidian[1] #= 0,
  Geode = new_array(N),
  Geode :: 0..255,
  Geode[1] #= 0,

  OreR = new_array(N),
  OreR :: 0..255,
  OreR[1] #= 1,
  ClayR = new_array(N),
  ClayR :: 0..255,
  ClayR[1] #= 0,
  ObsidianR = new_array(N),
  ObsidianR :: 0..255,
  ObsidianR[1] #= 0,
  GeodeR = new_array(N),
  GeodeR :: 0..255,
  GeodeR[1] #= 0,

  foreach(I in 2..N)
    % actions: 0 = wait, 1 = ore robot, 2 = clay robot, 3 = obsidian robot, 4 = geode robot
    Action #= Actions[I],

    % restrict actions requiring various ores
    Ore[I-1] #< Blueprint[1] #=> Action #!= 1,
    Ore[I-1] #< Blueprint[2] #=> Action #!= 2,
    Ore[I-1] #< Blueprint[3] #=> Action #!= 3,
    Clay[I-1] #< Blueprint[4] #=> Action #!= 3,
    Ore[I-1] #< Blueprint[5] #=> Action #!= 4,
    Obsidian[I-1] #< Blueprint[6] #=> Action #!= 4,

    % update ores
    [OreCost, ClayCost, ObsidianCost] :: 0..100,
    Action #= 0 #=> OreCost #= 0,
    Action #= 1 #=> OreCost #= Blueprint[1],
    Action #= 2 #=> OreCost #= Blueprint[2],
    Action #= 3 #=> OreCost #= Blueprint[3],
    Action #= 4 #=> OreCost #= Blueprint[5],
    Ore[I] #= Ore[I-1] + OreR[I-1] - OreCost,

    Action #!= 3 #=> ClayCost #= 0,
    Action #= 3 #=> ClayCost #= Blueprint[4],
    Clay[I] #= Clay[I-1] + ClayR[I-1] - ClayCost,

    Action #!= 4 #=> ObsidianCost #= 0,
    Action #= 4 #=> ObsidianCost #= Blueprint[6],
    Obsidian[I] #= Obsidian[I-1] + ObsidianR[I-1] - ObsidianCost,

    Geode[I] #= Geode[I-1] + GeodeR[I-1],

    % update robots
    OreR[I] #= OreR[I-1] + cond(Action #= 1, 1, 0),
    ClayR[I] #= ClayR[I-1] + cond(Action #= 2, 1, 0),
    ObsidianR[I] #= ObsidianR[I-1] + cond(Action #= 3, 1, 0),
    GeodeR[I] #= GeodeR[I-1] + cond(Action #= 4, 1, 0),
  end,

  TotalScore #= Geode[Geode.length()],
  solve([inout, split, $max(TotalScore)], Actions),
  println(actions2=Actions),
  R = TotalScore.

parse_line(S) = R =>
  Xs = split(S),
  % ugly parse. costs per robot/material: ore/ore, clay/ore, obsidian/ore, obsidian/clay, geode/ore, geode/obsidian
  R = map(parse_term, [Xs[7],Xs[13],Xs[19],Xs[22],Xs[28],Xs[31]]).
