% curiously, the "sat" module produces an incorrect result (and in fact segfaults on my input, maybe due to the
% size of the domain variables)
import cp.
import util.

main =>
  Lines = read_file_lines(),
  Monkeys = map(parse_line, Lines),

  T = new_map(),
  foreach(M in Monkeys)
    T.put(M[1], M.drop(1))
  end,

  crunch(T).

crunch(T) =>
  Root = T.get("root"),
  % I'm using "P" to recursively tie together the expression tree.
  P :: 0..100000000000000,
  X :: 0..100000000000000,
  calc("root",Root,T,X,P),
  println(x1=X),
  println(p=P),
  solve([split], [X,P]),
  println(x2=X).

calc("humn", _, T, X, P) =>
  println(humn=X),
  P #= X.
calc(Name, [K], T, X, P) =>
  Ki = K.to_int(),
  P #= Ki.
calc("root", [A,_,B], T, X, P) =>
  Am = T.get(A),
  Bm = T.get(B),
  calc(A,Am,T,X,P1),
  calc(B,Bm,T,X,P2),
  P #= P2,
  P1 #= P2.
calc(Name, [A,"+",B], T, X, P) =>
  Am = T.get(A),
  Bm = T.get(B),
  calc(A,Am,T,X,L),
  calc(B,Bm,T,X,R),
  P #= L + R.
calc(Name, [A,"-",B], T, X, P) =>
  Am = T.get(A),
  Bm = T.get(B),
  calc(A,Am,T,X,L),
  calc(B,Bm,T,X,R),
  P #= L - R.
calc(Name, [A,"*",B], T, X, P) =>
  Am = T.get(A),
  Bm = T.get(B),
  calc(A,Am,T,X,L),
  calc(B,Bm,T,X,R),
  P #= L * R.
calc(Name, [A,"/",B], T, X, P) =>
  Am = T.get(A),
  Bm = T.get(B),
  calc(A,Am,T,X,L),
  calc(B,Bm,T,X,R),
  P #= L / R.

parse_line(S) = split(S,": ").
